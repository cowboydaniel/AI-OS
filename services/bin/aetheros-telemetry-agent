#!/usr/bin/env python3
"""Telemetry agent that aggregates events and exposes metrics."""

from __future__ import annotations

import json
import logging
import logging.handlers
import os
import signal
import sys
import threading
import time
from http import HTTPStatus
from http.server import BaseHTTPRequestHandler, ThreadingHTTPServer
from pathlib import Path
from typing import Any, Dict

QUEUE_PATH = Path(os.getenv("AETHEROS_TELEMETRY_QUEUE", "/var/lib/aetheros/telemetry/events.log"))
METRICS_PATH = Path(os.getenv("AETHEROS_METRICS_PATH", "/var/lib/aetheros/telemetry/metrics.prom"))
HOST = os.getenv("AETHEROS_TELEMETRY_HOST", "0.0.0.0")
PORT = int(os.getenv("AETHEROS_TELEMETRY_PORT", "8043"))

_metrics_lock = threading.Lock()
_metrics: Dict[str, Any] = {
    "events_total": 0,
    "events_by_type": {},
    "last_event_ts": 0,
    "read_errors": 0,
}

shutdown_event = threading.Event()


def _snapshot_metrics() -> Dict[str, Any]:
    with _metrics_lock:
        return {
            "events_total": _metrics["events_total"],
            "events_by_type": dict(_metrics["events_by_type"]),
            "last_event_ts": _metrics["last_event_ts"],
            "read_errors": _metrics["read_errors"],
        }


def _configure_logging() -> logging.Logger:
    logger = logging.getLogger("aetheros.telemetry.agent")
    if logger.handlers:
        return logger

    logger.setLevel(logging.INFO)
    formatter = logging.Formatter(
        "%(asctime)s %(levelname)s %(name)s %(message)s",
        datefmt="%Y-%m-%dT%H:%M:%S%z",
    )

    stream_handler = logging.StreamHandler(sys.stdout)
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)

    log_path = Path("/var/log/aetheros/telemetry.log")
    log_path.parent.mkdir(parents=True, exist_ok=True)
    file_handler = logging.handlers.RotatingFileHandler(
        log_path, maxBytes=2_000_000, backupCount=3
    )
    file_handler.setFormatter(formatter)
    logger.addHandler(file_handler)

    return logger


def _persist_metrics() -> None:
    snapshot = _snapshot_metrics()
    lines = [
        "# HELP aetheros_telemetry_events_total Total telemetry events ingested.",
        "# TYPE aetheros_telemetry_events_total counter",
        f"aetheros_telemetry_events_total {snapshot['events_total']}",
        "# HELP aetheros_telemetry_read_errors Total telemetry read errors.",
        "# TYPE aetheros_telemetry_read_errors counter",
        f"aetheros_telemetry_read_errors {snapshot['read_errors']}",
        "# HELP aetheros_telemetry_last_event_ts Unix timestamp of last event.",
        "# TYPE aetheros_telemetry_last_event_ts gauge",
        f"aetheros_telemetry_last_event_ts {snapshot['last_event_ts']}",
    ]

    for event_type, count in snapshot["events_by_type"].items():
        lines.append(
            f"aetheros_telemetry_events_by_type_total{{type=\"{event_type}\"}} {count}"
        )

    METRICS_PATH.parent.mkdir(parents=True, exist_ok=True)
    METRICS_PATH.write_text("\n".join(lines) + "\n", encoding="utf-8")


def _record_event(event: Dict[str, Any], logger: logging.Logger) -> None:
    with _metrics_lock:
        _metrics["events_total"] += 1
        event_type = str(event.get("type", "unknown"))
        _metrics["events_by_type"][event_type] = _metrics["events_by_type"].get(event_type, 0) + 1
        _metrics["last_event_ts"] = int(event.get("ts", time.time()))
    logger.debug("Ingested telemetry event", extra={"event_type": event_type})
    _persist_metrics()


def _follow_events(logger: logging.Logger) -> None:
    QUEUE_PATH.parent.mkdir(parents=True, exist_ok=True)
    QUEUE_PATH.touch(exist_ok=True)

    with QUEUE_PATH.open("r", encoding="utf-8") as handle:
        handle.seek(0, os.SEEK_END)
        while not shutdown_event.is_set():
            line = handle.readline()
            if not line:
                time.sleep(1)
                continue
            try:
                event = json.loads(line)
            except json.JSONDecodeError:
                with _metrics_lock:
                    _metrics["read_errors"] += 1
                logger.warning("Skipped malformed telemetry line")
                continue

            _record_event(event, logger)


def _serve_http(logger: logging.Logger) -> ThreadingHTTPServer:
    class Handler(BaseHTTPRequestHandler):
        def _set_headers(self, status: HTTPStatus = HTTPStatus.OK, content_type: str = "application/json") -> None:
            self.send_response(status)
            self.send_header("Content-Type", content_type)
            self.end_headers()

        def log_message(self, format: str, *args: object) -> None:  # noqa: A003
            logger.info("%s - %s", self.address_string(), format % args)

        def do_GET(self) -> None:  # noqa: N802
            if self.path.startswith("/healthz"):
                snapshot = _snapshot_metrics()
                self._set_headers()
                self.wfile.write(
                    json.dumps({
                        "status": "ok",
                        "queue_path": str(QUEUE_PATH),
                        "metrics_path": str(METRICS_PATH),
                        "events_total": snapshot["events_total"],
                    }).encode("utf-8")
                )
                return

            if self.path.startswith("/metrics"):
                self._set_headers(content_type="text/plain")
                METRICS_PATH.parent.mkdir(parents=True, exist_ok=True)
                if METRICS_PATH.exists():
                    self.wfile.write(METRICS_PATH.read_bytes())
                else:
                    _persist_metrics()
                    self.wfile.write(METRICS_PATH.read_bytes())
                return

            self._set_headers(HTTPStatus.NOT_FOUND)
            self.wfile.write(json.dumps({"error": "unknown endpoint"}).encode("utf-8"))

    server = ThreadingHTTPServer((HOST, PORT), Handler)
    threading.Thread(target=server.serve_forever, daemon=True).start()
    logger.info("Telemetry agent listening", extra={"port": PORT, "host": HOST})
    return server


def main() -> None:
    logger = _configure_logging()
    ingest_thread = threading.Thread(target=_follow_events, args=(logger,), daemon=True)
    ingest_thread.start()
    server = _serve_http(logger)

    def _shutdown(signum: int, frame: Any) -> None:  # noqa: ARG001
        logger.info("Received signal %s, stopping telemetry agent", signum)
        shutdown_event.set()
        server.shutdown()

    signal.signal(signal.SIGTERM, _shutdown)
    signal.signal(signal.SIGINT, _shutdown)

    while not shutdown_event.is_set():
        time.sleep(0.5)

    server.server_close()
    ingest_thread.join(timeout=2)
    _persist_metrics()


if __name__ == "__main__":
    main()
